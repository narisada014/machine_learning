import linearreg
import numpy as np
import csv


# データ読み込み
Xy = []
with open("winequality-red.csv") as fp:
    for row in csv.reader(fp, delimiter=";"):  # delimiterはファイル内の区切りが何なのかを教えてあげる引数
        Xy.append(row)

# 特徴量のラベルであるインデックス0を排除する, またnp.arrayとすることで以下のように配列のn行1列の行列として扱える
# [[ 7.4    0.7    0.    ...  0.56   9.4    5.   ]
#  [ 7.8    0.88   0.    ...  0.68   9.8    5.   ]
#  [ 7.8    0.76   0.04  ...  0.65   9.8    5.   ]
#  ...
#  [ 6.3    0.51   0.13  ...  0.75  11.     6.   ]
#  [ 5.9    0.645  0.12  ...  0.71  10.2    5.   ]
#  [ 6.     0.31   0.47  ...  0.66  11.     6.   ]]

Xy = np.array(Xy[1:], dtype=np.float64)  # コラム: dtypeと指定する事で型が指定できPythonの速度が上がる

# 全てのデータを使うとテストができないので、訓練用とテスト用にデータを分割する。
np.random.seed(0)
# 順番をシャッフル
np.random.shuffle(Xy)
# データは1600行存在する(半分の800でやったら精度が低下したのでおそらく1000が一番精度が高くなったのか？と思う)
train_X = Xy[:-1000, :-1]
train_y = Xy[:-1000, -1]
test_X = Xy[-1000:, :-1]
test_y = Xy[-1000:, -1]
# 上記の参考に
# >>> a  = np.array([[1,2,3,4,5],[6,7,8,9,10]])
# >>> a
# array([[ 1,  2,  3,  4,  5],
#        [ 6,  7,  8,  9, 10]])
# >>> a[-1000:]
# array([[ 1,  2,  3,  4,  5],
#        [ 6,  7,  8,  9, 10]])
# >>> a[-1000:, :-1]
# array([[1, 2, 3, 4],
#        [6, 7, 8, 9]])
# >>> a[-1000:, -1]
# array([ 5, 10]) => 一番右端の次元のみの配列を取得することができる
# 今回の場合quality（一番最後の値でワインの質のこと）が出力データとなるのでtrain_yがXy[:-1000, -1]と表される

# 学習
model = linearreg.LinearRegression()
model.fit(train_X, train_y)

# テストデータから出力の予測を行う
y = model.predict(test_X)

print("最初の5つの正解と予測値：")
for i in range(5):
    print("{:1.0f} {:5.3f}".format(test_y[i], y[i]))
    # 1.0fの1の部分は行左からの距離を表す。5.3の5も距離。1.0   2.0のように間隔を作りたい時にいい。
    # 5.3の3のような小数点以下の数字は小数点以下の有効桁を表す。
    # 書式を指定して埋め込む場合は、以下のようにします。
    #
    # '{0:指定したい書式の型}'
    # format(変数)
    # {}の中に :を書き、その右側に指定したい書式の型を書くことで、書式を指定することができる。
    # 今回の場合だと、numpyでfloat指定しているのでfloatで指定しないといけない1.0f, 5.3fは型を表す
print()
# テスト出力とモデルの推測を使った推測値の差の2乗ででた配列の各要素の平均をルートしたものがRMSE(平均二乗誤差のルート)
print("RMSE:", np.sqrt(((test_y - y)**2).mean()))
